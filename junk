pub fn _get_moves(board: &mut Board, player: i32) ->  Vec<BoardMove> {
    
    // Try All Adjacent 
    let mut offensive_moves : Vec<(BoardMove, i32)> = Vec::new();
    let mut defensive_moves : Vec<(BoardMove, i32)> = Vec::new();
    for x in 0..board.size {
        for y in 0..board.size {            
            if is_candidate(board, x as i32, y as i32, player) {
                let mut candidate = BoardMove::new(x, y, player);
                let score = evaluate_move(board, &mut candidate);
                if score >= 0 {
                    offensive_moves.push((candidate, score));
                }
                else {
                    defensive_moves.push((candidate, score));
                }
            }
        }
    }

    // Sort candidates based on score (Offense / Defense).
    offensive_moves.sort_by(|a, b| b.1.cmp(&a.1)); 
    let mut o_sorted = Vec::new();

    defensive_moves.sort_by(|a, b| b.1.cmp(&a.1)); 
    let mut d_sorted = Vec::new();

    for m in offensive_moves {
        o_sorted.push(m.0);
    }
    if o_sorted.len() > CANDIDATE_SELECT {
        o_sorted = o_sorted[0..CANDIDATE_SELECT].to_vec();
    }
    
    
    for m in defensive_moves {
        d_sorted.push(m.0);
    }
    if d_sorted.len() > CANDIDATE_SELECT {
        d_sorted = d_sorted[0..CANDIDATE_SELECT].to_vec();
    }
    
    o_sorted.extend(d_sorted);
    
    // Add random at end.
    let r_move = get_random_move(board, player);
    if r_move.x != -1 {
        o_sorted.push(r_move);
    }
    return o_sorted;
}



if delta > 50 {
        for i in 0..offensive_moves.len() {
            if (offensive_moves[i].score) >= (min as f64 + (delta as f64) * 0.90).round() as i32 {
                offset += 1;
            }
        }
  
    }


    if offset < CANDIDATE_SELECT {
        let len = offensive_moves.len() as i32;
        offset = CANDIDATE_SELECT;
        offset = offset.min(len.try_into().unwrap());
    }

    offensive_moves = offensive_moves[0..offset].to_vec();